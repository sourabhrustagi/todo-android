package com.mobizonetech.todo.presentation.auth

import com.mobizonetech.todo.domain.repository.AuthRepository
import io.mockk.coEvery
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Assert.assertNotNull
import org.junit.Before
import org.junit.Test

@OptIn(ExperimentalCoroutinesApi::class)
class LoginViewModelTest {

    private lateinit var viewModel: LoginViewModel
    private lateinit var authRepository: AuthRepository
    private val testDispatcher = StandardTestDispatcher()

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        authRepository = mockk()
        viewModel = LoginViewModel(authRepository)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `initial state should be correct`() = runTest {
        val initialState = viewModel.uiState.value
        
        assertFalse(initialState.isLoading)
        assertFalse(initialState.otpRequested)
        assertFalse(initialState.isAuthenticated)
        assertNull(initialState.error)
        assertNull(initialState.message)
    }

    @Test
    fun `login with valid phone number should request OTP`() = runTest {
        val phoneNumber = "1234567890"
        val expectedMessage = "OTP sent successfully"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.success(expectedMessage)
        
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertTrue(state.otpRequested)
        assertEquals(expectedMessage, state.message)
        assertNull(state.error)
    }

    @Test
    fun `login with invalid phone number should show error`() = runTest {
        val phoneNumber = "invalid"
        val errorMessage = "Invalid phone number"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.failure(Exception(errorMessage))
        
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertFalse(state.otpRequested)
        assertEquals(errorMessage, state.error)
        assertNull(state.message)
    }

    @Test
    fun `verify OTP with valid credentials should succeed`() = runTest {
        val phoneNumber = "1234567890"
        val otp = "123456"
        
        coEvery { authRepository.verifyOtp(phoneNumber, otp) } returns Result.success(Unit)
        
        viewModel.verifyOtp(phoneNumber, otp)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertTrue(state.isAuthenticated)
        assertNull(state.error)
    }

    @Test
    fun `verify OTP with invalid credentials should show error`() = runTest {
        val phoneNumber = "1234567890"
        val otp = "000000"
        val errorMessage = "Invalid OTP"
        
        coEvery { authRepository.verifyOtp(phoneNumber, otp) } returns Result.failure(Exception(errorMessage))
        
        viewModel.verifyOtp(phoneNumber, otp)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertFalse(state.isAuthenticated)
        assertEquals(errorMessage, state.error)
        assertNull(state.message)
    }

    @Test
    fun `loading state should be set during login`() = runTest {
        val phoneNumber = "1234567890"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.success("Success")
        
        viewModel.login(phoneNumber)
        
        // Check loading state immediately after login call
        val loadingState = viewModel.uiState.value
        assertTrue(loadingState.isLoading)
        
        testDispatcher.scheduler.advanceUntilIdle()
        
        // Check final state after completion
        val finalState = viewModel.uiState.value
        assertFalse(finalState.isLoading)
    }

    @Test
    fun `loading state should be set during OTP verification`() = runTest {
        val phoneNumber = "1234567890"
        val otp = "123456"
        
        coEvery { authRepository.verifyOtp(phoneNumber, otp) } returns Result.success(Unit)
        
        viewModel.verifyOtp(phoneNumber, otp)
        
        // Check loading state immediately after verify call
        val loadingState = viewModel.uiState.value
        assertTrue(loadingState.isLoading)
        
        testDispatcher.scheduler.advanceUntilIdle()
        
        // Check final state after completion
        val finalState = viewModel.uiState.value
        assertFalse(finalState.isLoading)
    }

    @Test
    fun `multiple login calls should handle state correctly`() = runTest {
        val phoneNumber = "1234567890"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.success("Success")
        
        viewModel.login(phoneNumber)
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertFalse(state.isLoading)
        assertTrue(state.otpRequested)
    }

    @Test
    fun `error should be cleared on successful login`() = runTest {
        val phoneNumber = "1234567890"
        
        // First call fails
        coEvery { authRepository.login(phoneNumber) } returns Result.failure(Exception("Error"))
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        // Second call succeeds
        coEvery { authRepository.login(phoneNumber) } returns Result.success("Success")
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        val state = viewModel.uiState.value
        assertNull(state.error)
        assertTrue(state.otpRequested)
    }

    @Test
    fun `clearError should clear error state`() = runTest {
        val phoneNumber = "invalid"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.failure(Exception("Error"))
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        // Verify error is set
        val stateWithError = viewModel.uiState.value
        assertNotNull(stateWithError.error)
        
        // Clear error
        viewModel.clearError()
        
        // Verify error is cleared
        val stateAfterClear = viewModel.uiState.value
        assertNull(stateAfterClear.error)
    }

    @Test
    fun `clearMessage should clear message state`() = runTest {
        val phoneNumber = "1234567890"
        
        coEvery { authRepository.login(phoneNumber) } returns Result.success("Success")
        viewModel.login(phoneNumber)
        testDispatcher.scheduler.advanceUntilIdle()
        
        // Verify message is set
        val stateWithMessage = viewModel.uiState.value
        assertNotNull(stateWithMessage.message)
        
        // Clear message
        viewModel.clearMessage()
        
        // Verify message is cleared
        val stateAfterClear = viewModel.uiState.value
        assertNull(stateAfterClear.message)
    }
} 